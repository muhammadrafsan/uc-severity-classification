# -*- coding: utf-8 -*-
"""single-multimodal-flava-average.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JLEfyBUGO5LnJ9e3ImhjH2ShiBYMNLGr
"""

import os
import torch
import numpy as np
import random
from PIL import Image
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, ConfusionMatrixDisplay
from tqdm import tqdm
from transformers import FlavaProcessor, FlavaModel

# Paths to your dataset folders
mild_path = '/kaggle/input/ulcerative-colitis-binary-dataset/Binary Ulceraive Colitis/mild'
severe_path = '/kaggle/input/ulcerative-colitis-binary-dataset/Binary Ulceraive Colitis/severe'

mild_images = [os.path.join(mild_path, img) for img in os.listdir(mild_path)]
severe_images = [os.path.join(severe_path, img) for img in os.listdir(severe_path)]

all_images = mild_images + severe_images
all_labels = [0] * len(mild_images) + [1] * len(severe_images)
from sklearn.model_selection import train_test_split
train_images, test_images, train_labels, test_labels = train_test_split(all_images, all_labels, test_size=0.1, stratify=all_labels, random_state=42)

device = "cuda" if torch.cuda.is_available() else "cpu"
processor = FlavaProcessor.from_pretrained("facebook/flava-full")
model = FlavaModel.from_pretrained("facebook/flava-full").to(device)

def encode_images_flava(images_list, batch_size=8):
    features = []
    with torch.no_grad():
        for i in tqdm(range(0, len(images_list), batch_size)):
            batch_images = images_list[i:i + batch_size]
            batch_features = []
            for image_path in batch_images:
                image = Image.open(image_path)
                inputs = processor(images=image, return_tensors="pt").to(device)
                image_features = model.get_image_features(**inputs)
                batch_features.append(image_features.cpu())
            features.append(torch.cat(batch_features))
    return torch.cat(features)

print("Extracting FLAVA features for training images...")
flava_train_features = encode_images_flava(train_images, batch_size=8)

print("Extracting FLAVA features for test images...")
flava_test_features = encode_images_flava(test_images, batch_size=8)

torch.save(flava_train_features, "flava_train_features.pt")
torch.save(flava_test_features, "flava_test_features.pt")
def compute_class_prototypes(features, labels):
    mild_features = []
    severe_features = []

    for feature, label in zip(features, labels):
        if label == 0:
            mild_features.append(feature)
        else:
            severe_features.append(feature)

    mild_prototype = torch.mean(torch.stack(mild_features), dim=0)
    severe_prototype = torch.mean(torch.stack(severe_features), dim=0)

    return mild_prototype, severe_prototype

print("Computing FLAVA class prototypes...")
flava_mild_prototype, flava_severe_prototype = compute_class_prototypes(flava_train_features, train_labels)

import torch.nn.functional as F

def classify_with_threshold(test_features, mild_prototype, severe_prototype, threshold=0.5):
    predictions = []
    for feature in test_features:
        mild_similarity = F.cosine_similarity(feature, mild_prototype.unsqueeze(0)).mean()
        severe_similarity = F.cosine_similarity(feature, severe_prototype.unsqueeze(0)).mean()
        normalized_similarity = mild_similarity / (mild_similarity + severe_similarity)
        if normalized_similarity > threshold:
            predictions.append(0)
        else:
            predictions.append(1)
    return predictions

print("Classifying test images using FLAVA...")
flava_predictions = classify_with_threshold(flava_test_features, flava_mild_prototype, flava_severe_prototype, threshold=0.5)

accuracy = accuracy_score(test_labels, flava_predictions)
print(f"FLAVA Accuracy: {accuracy * 100:.2f}%")

report = classification_report(test_labels, flava_predictions, target_names=["Mild", "Severe"])
print(report)

conf_matrix = confusion_matrix(test_labels, flava_predictions)
disp = ConfusionMatrixDisplay(confusion_matrix=conf_matrix, display_labels=["Mild", "Severe"])
disp.plot(cmap="Blues")
disp.ax_.set_title("FLAVA Confusion Matrix")
disp.figure_.tight_layout()

def classify_with_euclidean_distance(test_features, mild_prototype, severe_prototype):
    predictions = []
    for feature in test_features:

        mild_distance = torch.norm(feature - mild_prototype)
        severe_distance = torch.norm(feature - severe_prototype)

        if mild_distance < severe_distance:
            predictions.append(0)
        else:
            predictions.append(1)
    return predictions

print("Classifying test images using FLAVA with Euclidean Distance...")
flava_predictions = classify_with_euclidean_distance(flava_test_features, flava_mild_prototype, flava_severe_prototype)

accuracy = accuracy_score(test_labels, flava_predictions)
print(f"FLAVA Accuracy (Euclidean Distance): {accuracy * 100:.2f}%")

report = classification_report(test_labels, flava_predictions, target_names=["Mild", "Severe"])
print(report)

conf_matrix = confusion_matrix(test_labels, flava_predictions)
disp = ConfusionMatrixDisplay(confusion_matrix=conf_matrix, display_labels=["Mild", "Severe"])
disp.plot(cmap="Blues")
disp.ax_.set_title("FLAVA Confusion Matrix (Euclidean Distance)")
disp.figure_.tight_layout()

def classify_with_manhattan_distance(test_features, mild_prototype, severe_prototype):
    predictions = []
    for feature in test_features:

        mild_distance = torch.sum(torch.abs(feature - mild_prototype))
        severe_distance = torch.sum(torch.abs(feature - severe_prototype))

        if mild_distance < severe_distance:
            predictions.append(0)
        else:
            predictions.append(1)
    return predictions

print("Classifying test images using FLAVA with Manhattan Distance...")
flava_predictions = classify_with_manhattan_distance(flava_test_features, flava_mild_prototype, flava_severe_prototype)


accuracy = accuracy_score(test_labels, flava_predictions)
print(f"FLAVA Accuracy with Manhattan Distance: {accuracy * 100:.2f}%")


report = classification_report(test_labels, flava_predictions, target_names=["Mild", "Severe"])
print(report)

conf_matrix = confusion_matrix(test_labels, flava_predictions)
disp = ConfusionMatrixDisplay(confusion_matrix=conf_matrix, display_labels=["Mild", "Severe"])
disp.plot(cmap="Blues")
disp.ax_.set_title("FLAVA Confusion Matrix with Manhattan Distance")
disp.figure_.tight_layout()

def compute_class_prototypes(features, labels):
    mild_features = []
    severe_features = []

    for feature, label in zip(features, labels):
        if label == 0:
            mild_features.append(feature)
        else:
            severe_features.append(feature)


    mild_prototype = torch.mean(torch.stack(mild_features), dim=0)
    severe_prototype = torch.mean(torch.stack(severe_features), dim=0)

    return mild_prototype, severe_prototype

def pearson_correlation(x, y):
    x_mean = x.mean()
    y_mean = y.mean()
    numerator = ((x - x_mean) * (y - y_mean)).sum()
    denominator = torch.sqrt(((x - x_mean) ** 2).sum()) * torch.sqrt(((y - y_mean) ** 2).sum())
    return numerator / denominator


def classify_with_pearson(test_features, mild_prototype, severe_prototype):
    predictions = []
    for feature in test_features:

        mild_correlation = pearson_correlation(feature, mild_prototype)
        severe_correlation = pearson_correlation(feature, severe_prototype)

        if mild_correlation > severe_correlation:
            predictions.append(0)
        else:
            predictions.append(1)
    return predictions

train_features = encode_images_flava(train_images, batch_size=8)
test_features = encode_images_flava(test_images, batch_size=8)

mild_prototype, severe_prototype = compute_class_prototypes(train_features, train_labels)


print("Classifying test images using Pearson correlation...")
flava_predictions = classify_with_pearson(test_features, mild_prototype, severe_prototype)

accuracy = accuracy_score(test_labels, flava_predictions)
print(f"FLAVA with Pearson Correlation Accuracy: {accuracy * 100:.2f}%")

report = classification_report(test_labels, flava_predictions, target_names=["Mild", "Severe"])
print(report)

conf_matrix = confusion_matrix(test_labels, flava_predictions)
disp = ConfusionMatrixDisplay(confusion_matrix=conf_matrix, display_labels=["Mild", "Severe"])
disp.plot(cmap="Blues")
disp.ax_.set_title("FLAVA with Pearson Correlation Confusion Matrix")
disp.figure_.tight_layout()











