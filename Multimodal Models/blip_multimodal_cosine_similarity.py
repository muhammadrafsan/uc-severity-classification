# -*- coding: utf-8 -*-
"""Ulcerative_colitis_with_BLIP_multimodal_Cosine_Similarity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eISMQM4WU3GTyG05FzoMBC-yw0FaM7jl
"""

!pip install transformers

import torch
from transformers import BlipModel, BlipProcessor
from PIL import Image
from torchvision import transforms
import numpy as np
import os
from google.colab import drive
drive.mount('/content/drive')

device = "cuda" if torch.cuda.is_available() else "cpu"

model = BlipModel.from_pretrained("Salesforce/blip-image-captioning-base").to(device)
processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")

preprocess = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

class_descriptions_split = [
    [
        "Mild Ulcerative Colitis: The colon appears relatively healthy with a reddish or pinkish hue, indicating low-grade inflammation.",
        "The mucosal surface is generally smooth, with a visible vascular pattern. Small superficial erosions may be present, but ulcerations are shallow and scattered.",
        "There is little to no bleeding, and the overall appearance reflects minimal damage confined to the mucosa."
    ],
    [
        "Severe Ulcerative Colitis: The colon takes on a deep red or purplish color, indicating severe inflammation.",
        "The surface is irregular, with prominent ulcerations that span large areas and reach deeper layers of the colon.",
        "Blood vessels are no longer visible due to thickened tissue, and bleeding often occurs spontaneously or upon contact."
    ]
]

mild_description = " ".join(class_descriptions_split[0])
severe_description = " ".join(class_descriptions_split[1])

def encode_text(description):
    inputs = processor(text=description, return_tensors="pt", padding=True).to(device)

    with torch.no_grad():
        outputs = model.get_text_features(**inputs)

    normalized_text_embedding = outputs / outputs.norm(dim=-1, keepdim=True)

    return normalized_text_embedding

mild_feature = encode_text(mild_description)
severe_feature = encode_text(severe_description)

text_features = torch.stack([mild_feature, severe_feature])

def extract_blip_image_features(image_path):
    image = Image.open(image_path).convert("RGB")

    inputs = processor(images=image, return_tensors="pt").to(device)

    with torch.no_grad():
        outputs = model.get_image_features(pixel_values=inputs.pixel_values)

    normalized_image_feature = outputs / outputs.norm(dim=-1, keepdim=True)

    return normalized_image_feature

def extract_train_image_features(image_folder):
    image_features = []
    labels = []

    for label in ["mild", "severe"]:
        label_folder = os.path.join(image_folder, label)
        image_files = [os.path.join(label_folder, img) for img in os.listdir(label_folder) if img.endswith(('jpg', 'png'))]

        for image_path in image_files:
            feature = extract_blip_image_features(image_path)
            image_features.append(feature.cpu().numpy())
            labels.append(label)

    return np.vstack(image_features), np.array(labels)

train_image_folder = "/content/drive/MyDrive/Few Shot Ulcerative Colitis Binary/train"

# Extract features and labels from the training images
train_features, train_labels = extract_train_image_features(train_image_folder)

# Function to calculate the average feature vector for each class
def calculate_class_prototypes(features, labels):
    mild_features = features[labels == "mild"]
    severe_features = features[labels == "severe"]

    # Calculate the average feature vector for each class
    mild_prototype = np.mean(mild_features, axis=0)
    severe_prototype = np.mean(severe_features, axis=0)

    return mild_prototype, severe_prototype

# Calculate the average feature vectors (prototypes)
mild_prototype, severe_prototype = calculate_class_prototypes(train_features, train_labels)

# Function to calculate cosine similarity
def cosine_similarity(a, b):
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# Function to classify a new image based on cosine similarity
def classify_image(image_path, mild_prototype, severe_prototype):
    # Extract image feature
    image_feature = extract_blip_image_features(image_path).cpu().numpy()

    # Calculate cosine similarity with both class prototypes
    mild_similarity = cosine_similarity(image_feature, mild_prototype)
    severe_similarity = cosine_similarity(image_feature, severe_prototype)

    # Return the class with the highest similarity
    return "mild" if mild_similarity > severe_similarity else "severe"

def evaluate_classifier(test_folder, mild_prototype, severe_prototype):
    correct_predictions = 0
    total_images = 0

    for label in ["mild", "severe"]:
        label_folder = os.path.join(test_folder, label)
        image_files = [os.path.join(label_folder, img) for img in os.listdir(label_folder) if img.endswith(('jpg', 'png'))]

        for image_path in image_files:
            predicted_label = classify_image(image_path, mild_prototype, severe_prototype)
            true_label = "mild" if label == "mild" else "severe"
            if predicted_label == true_label:
                correct_predictions += 1
            total_images += 1

    accuracy = correct_predictions / total_images if total_images > 0 else 0
    return accuracy

test_image_folder = "/content/drive/MyDrive/Few Shot Ulcerative Colitis Binary/test"

test_accuracy = evaluate_classifier(test_image_folder, mild_prototype, severe_prototype)
print(f"Test Accuracy: {test_accuracy * 100:.2f}%")





















