# -*- coding: utf-8 -*-
"""Ulcerative_Colitis_ViT_L_14_Manhattan_metric.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Susdo-TfshYCWf-k3xW0-BS4duH3ZHjZ
"""

!pip install git+https://github.com/openai/CLIP.git

import torch
import clip
from PIL import Image
import os
import numpy as np

device = "cuda" if torch.cuda.is_available() else "cpu"

model, preprocess = clip.load("ViT-L/14", device=device)

from google.colab import drive
drive.mount('/content/drive')

class_descriptions_split = [
    [
        "In mild or inactive ulcerative colitis, the colonâ€™s mucosa appears relatively healthy, with a reddish-pink hue that suggests mild, low-grade inflammation.",
        "The surface remains smooth and intact, with a clearly visible and defined vascular pattern, indicating that the inflammation has not yet thickened the tissue.",
        "Small, superficial erosions may be present, but they are infrequent, scattered, and do not penetrate deeply into the colon wall."
    ],
    [
        "In severe or active ulcerative colitis, the colon appears deep red or purplish, indicating widespread and significant inflammation.",
        "The mucosa is fragile (friable), with the surface becoming highly irregular, showing deep and prominent ulcerations that extend over large areas.",
        "Bleeding often occurs spontaneously or upon the slightest contact, and the vascular pattern is obscured due to the thickening and damage of the tissue."
    ]
]

def encode_description_parts(description_parts):
    part_features = []
    for part in description_parts:
        text_input = clip.tokenize(part).to(device)
        with torch.no_grad():
            part_feature = model.encode_text(text_input)
            part_feature /= part_feature.norm(dim=-1, keepdim=True)
            part_features.append(part_feature)
    return torch.mean(torch.cat(part_features), dim=0)

mild_feature = encode_description_parts(class_descriptions_split[0])
severe_feature = encode_description_parts(class_descriptions_split[1])

text_features = torch.stack([mild_feature, severe_feature])

def load_and_preprocess_images(image_paths):
    images = [preprocess(Image.open(image_path)).unsqueeze(0).to(device) for image_path in image_paths]
    return torch.cat(images)

def extract_image_features(image_folder):
    image_features = []
    labels = []

    for label in ["mild", "severe"]:
        label_folder = os.path.join(image_folder, label)
        image_files = [os.path.join(label_folder, img) for img in os.listdir(label_folder) if img.endswith(('jpg', 'png'))]

        for image_path in image_files:
            image = preprocess(Image.open(image_path)).unsqueeze(0).to(device)
            with torch.no_grad():
                feature = model.encode_image(image)
                feature /= feature.norm(dim=-1, keepdim=True)
                image_features.append(feature.cpu().numpy())
                labels.append(label)

    return np.vstack(image_features), np.array(labels)

train_image_folder = "/content/drive/MyDrive/test2"

train_features, train_labels = extract_image_features(train_image_folder)

from sklearn.neighbors import KNeighborsClassifier

def train_knn_classifier(features, labels, k=13):
    knn = KNeighborsClassifier(n_neighbors=k, weights='distance', metric='manhattan')
    knn.fit(features, labels)
    return knn

knn_classifier = train_knn_classifier(train_features, train_labels)

def classify_image_with_knn(knn, image_path):
    image = preprocess(Image.open(image_path)).unsqueeze(0).to(device)

    with torch.no_grad():
        feature = model.encode_image(image)
        feature /= feature.norm(dim=-1, keepdim=True)

    predicted_label = knn.predict(feature.cpu().numpy())
    return predicted_label[0]

def test_knn_accuracy(knn, test_folder):
    correct_predictions = 0
    total_images = 0

    for label in ["mild", "severe"]:
        label_folder = os.path.join(test_folder, label)
        image_files = [os.path.join(label_folder, img) for img in os.listdir(label_folder) if img.endswith(('jpg', 'png'))]

        for image_path in image_files:
            predicted_label = classify_image_with_knn(knn, image_path)
            true_label = "mild" if label == "mild" else "severe"
            if predicted_label == true_label:
                correct_predictions += 1
            total_images += 1

    accuracy = correct_predictions / total_images if total_images > 0 else 0
    return accuracy

test_image_folder = "/content/drive/MyDrive/Few Shot Ulcerative Colitis Binary/test"

test_accuracy = test_knn_accuracy(knn_classifier, test_image_folder)
print(f"Test Accuracy (KNN): {test_accuracy * 100:.2f}%")



